"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmy_react_app"] = self["webpackChunkmy_react_app"] || []).push([[834],{

/***/ 3737:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V: () => (/* binding */ Treemap)\n/* harmony export */ });\n/* harmony import */ var lodash_isNaN__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1741);\n/* harmony import */ var lodash_isNaN__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_isNaN__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1882);\n/* harmony import */ var lodash_isFunction__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isFunction__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(179);\n/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_omit__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8156);\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(4164);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6540);\n/* harmony import */ var react_smooth__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1372);\n/* harmony import */ var _component_Tooltip__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(2149);\n/* harmony import */ var _container_Layer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6069);\n/* harmony import */ var _container_Surface__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(9303);\n/* harmony import */ var _shape_Polygon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(852);\n/* harmony import */ var _shape_Rectangle__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(4723);\n/* harmony import */ var _util_ChartUtils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(3964);\n/* harmony import */ var _util_Constants__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(4364);\n/* harmony import */ var _util_DataUtils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(9744);\n/* harmony import */ var _util_DOMUtils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(1636);\n/* harmony import */ var _util_Global__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(9938);\n/* harmony import */ var _util_ReactUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4501);\nvar _excluded = [\"width\", \"height\", \"className\", \"style\", \"children\", \"type\"];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } } return target; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n/**\n * @fileOverview TreemapChart\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar NODE_VALUE_KEY = 'value';\nvar computeNode = function computeNode(_ref) {\n  var depth = _ref.depth,\n    node = _ref.node,\n    index = _ref.index,\n    valueKey = _ref.valueKey;\n  var children = node.children;\n  var childDepth = depth + 1;\n  var computedChildren = children && children.length ? children.map(function (child, i) {\n    return computeNode({\n      depth: childDepth,\n      node: child,\n      index: i,\n      valueKey: valueKey\n    });\n  }) : null;\n  var nodeValue;\n  if (children && children.length) {\n    nodeValue = computedChildren.reduce(function (result, child) {\n      return result + child[NODE_VALUE_KEY];\n    }, 0);\n  } else {\n    // TODO need to verify valueKey\n    nodeValue = lodash_isNaN__WEBPACK_IMPORTED_MODULE_0___default()(node[valueKey]) || node[valueKey] <= 0 ? 0 : node[valueKey];\n  }\n  return _objectSpread(_objectSpread({}, node), {}, _defineProperty(_defineProperty(_defineProperty({\n    children: computedChildren\n  }, NODE_VALUE_KEY, nodeValue), \"depth\", depth), \"index\", index));\n};\nvar filterRect = function filterRect(node) {\n  return {\n    x: node.x,\n    y: node.y,\n    width: node.width,\n    height: node.height\n  };\n};\n\n// Compute the area for each child based on value & scale.\nvar getAreaOfChildren = function getAreaOfChildren(children, areaValueRatio) {\n  var ratio = areaValueRatio < 0 ? 0 : areaValueRatio;\n  return children.map(function (child) {\n    var area = child[NODE_VALUE_KEY] * ratio;\n    return _objectSpread(_objectSpread({}, child), {}, {\n      area: lodash_isNaN__WEBPACK_IMPORTED_MODULE_0___default()(area) || area <= 0 ? 0 : area\n    });\n  });\n};\n\n// Computes the score for the specified row, as the worst aspect ratio.\nvar getWorstScore = function getWorstScore(row, parentSize, aspectRatio) {\n  var parentArea = parentSize * parentSize;\n  var rowArea = row.area * row.area;\n  var _row$reduce = row.reduce(function (result, child) {\n      return {\n        min: Math.min(result.min, child.area),\n        max: Math.max(result.max, child.area)\n      };\n    }, {\n      min: Infinity,\n      max: 0\n    }),\n    min = _row$reduce.min,\n    max = _row$reduce.max;\n  return rowArea ? Math.max(parentArea * max * aspectRatio / rowArea, rowArea / (parentArea * min * aspectRatio)) : Infinity;\n};\nvar horizontalPosition = function horizontalPosition(row, parentSize, parentRect, isFlush) {\n  var rowHeight = parentSize ? Math.round(row.area / parentSize) : 0;\n  if (isFlush || rowHeight > parentRect.height) {\n    rowHeight = parentRect.height;\n  }\n  var curX = parentRect.x;\n  var child;\n  for (var i = 0, len = row.length; i < len; i++) {\n    child = row[i];\n    child.x = curX;\n    child.y = parentRect.y;\n    child.height = rowHeight;\n    child.width = Math.min(rowHeight ? Math.round(child.area / rowHeight) : 0, parentRect.x + parentRect.width - curX);\n    curX += child.width;\n  }\n  // add the remain x to the last one of row\n  child.width += parentRect.x + parentRect.width - curX;\n  return _objectSpread(_objectSpread({}, parentRect), {}, {\n    y: parentRect.y + rowHeight,\n    height: parentRect.height - rowHeight\n  });\n};\nvar verticalPosition = function verticalPosition(row, parentSize, parentRect, isFlush) {\n  var rowWidth = parentSize ? Math.round(row.area / parentSize) : 0;\n  if (isFlush || rowWidth > parentRect.width) {\n    rowWidth = parentRect.width;\n  }\n  var curY = parentRect.y;\n  var child;\n  for (var i = 0, len = row.length; i < len; i++) {\n    child = row[i];\n    child.x = parentRect.x;\n    child.y = curY;\n    child.width = rowWidth;\n    child.height = Math.min(rowWidth ? Math.round(child.area / rowWidth) : 0, parentRect.y + parentRect.height - curY);\n    curY += child.height;\n  }\n  if (child) {\n    child.height += parentRect.y + parentRect.height - curY;\n  }\n  return _objectSpread(_objectSpread({}, parentRect), {}, {\n    x: parentRect.x + rowWidth,\n    width: parentRect.width - rowWidth\n  });\n};\nvar position = function position(row, parentSize, parentRect, isFlush) {\n  if (parentSize === parentRect.width) {\n    return horizontalPosition(row, parentSize, parentRect, isFlush);\n  }\n  return verticalPosition(row, parentSize, parentRect, isFlush);\n};\n\n// Recursively arranges the specified node's children into squarified rows.\nvar squarify = function squarify(node, aspectRatio) {\n  var children = node.children;\n  if (children && children.length) {\n    var rect = filterRect(node);\n    // maybe a bug\n    var row = [];\n    var best = Infinity; // the best row score so far\n    var child, score; // the current row score\n    var size = Math.min(rect.width, rect.height); // initial orientation\n    var scaleChildren = getAreaOfChildren(children, rect.width * rect.height / node[NODE_VALUE_KEY]);\n    var tempChildren = scaleChildren.slice();\n    row.area = 0;\n    while (tempChildren.length > 0) {\n      // row first\n      // eslint-disable-next-line prefer-destructuring\n      row.push(child = tempChildren[0]);\n      row.area += child.area;\n      score = getWorstScore(row, size, aspectRatio);\n      if (score <= best) {\n        // continue with this orientation\n        tempChildren.shift();\n        best = score;\n      } else {\n        // abort, and try a different orientation\n        row.area -= row.pop().area;\n        rect = position(row, size, rect, false);\n        size = Math.min(rect.width, rect.height);\n        row.length = row.area = 0;\n        best = Infinity;\n      }\n    }\n    if (row.length) {\n      rect = position(row, size, rect, true);\n      row.length = row.area = 0;\n    }\n    return _objectSpread(_objectSpread({}, node), {}, {\n      children: scaleChildren.map(function (c) {\n        return squarify(c, aspectRatio);\n      })\n    });\n  }\n  return node;\n};\nvar defaultState = {\n  isTooltipActive: false,\n  isAnimationFinished: false,\n  activeNode: null,\n  formatRoot: null,\n  currentRoot: null,\n  nestIndex: []\n};\nvar Treemap = /*#__PURE__*/function (_PureComponent) {\n  function Treemap() {\n    var _this;\n    _classCallCheck(this, Treemap);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _callSuper(this, Treemap, [].concat(args));\n    _defineProperty(_this, \"state\", _objectSpread({}, defaultState));\n    _defineProperty(_this, \"handleAnimationEnd\", function () {\n      var onAnimationEnd = _this.props.onAnimationEnd;\n      _this.setState({\n        isAnimationFinished: true\n      });\n      if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_1___default()(onAnimationEnd)) {\n        onAnimationEnd();\n      }\n    });\n    _defineProperty(_this, \"handleAnimationStart\", function () {\n      var onAnimationStart = _this.props.onAnimationStart;\n      _this.setState({\n        isAnimationFinished: false\n      });\n      if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_1___default()(onAnimationStart)) {\n        onAnimationStart();\n      }\n    });\n    return _this;\n  }\n  _inherits(Treemap, _PureComponent);\n  return _createClass(Treemap, [{\n    key: \"handleMouseEnter\",\n    value: function handleMouseEnter(node, e) {\n      e.persist();\n      var _this$props = this.props,\n        onMouseEnter = _this$props.onMouseEnter,\n        children = _this$props.children;\n      var tooltipItem = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_5__/* .findChildByType */ .BU)(children, _component_Tooltip__WEBPACK_IMPORTED_MODULE_6__/* .Tooltip */ .m);\n      if (tooltipItem) {\n        this.setState({\n          isTooltipActive: true,\n          activeNode: node\n        }, function () {\n          if (onMouseEnter) {\n            onMouseEnter(node, e);\n          }\n        });\n      } else if (onMouseEnter) {\n        onMouseEnter(node, e);\n      }\n    }\n  }, {\n    key: \"handleMouseLeave\",\n    value: function handleMouseLeave(node, e) {\n      e.persist();\n      var _this$props2 = this.props,\n        onMouseLeave = _this$props2.onMouseLeave,\n        children = _this$props2.children;\n      var tooltipItem = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_5__/* .findChildByType */ .BU)(children, _component_Tooltip__WEBPACK_IMPORTED_MODULE_6__/* .Tooltip */ .m);\n      if (tooltipItem) {\n        this.setState({\n          isTooltipActive: false,\n          activeNode: null\n        }, function () {\n          if (onMouseLeave) {\n            onMouseLeave(node, e);\n          }\n        });\n      } else if (onMouseLeave) {\n        onMouseLeave(node, e);\n      }\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(node) {\n      var _this$props3 = this.props,\n        onClick = _this$props3.onClick,\n        type = _this$props3.type;\n      if (type === 'nest' && node.children) {\n        var _this$props4 = this.props,\n          width = _this$props4.width,\n          height = _this$props4.height,\n          dataKey = _this$props4.dataKey,\n          aspectRatio = _this$props4.aspectRatio;\n        var root = computeNode({\n          depth: 0,\n          node: _objectSpread(_objectSpread({}, node), {}, {\n            x: 0,\n            y: 0,\n            width: width,\n            height: height\n          }),\n          index: 0,\n          valueKey: dataKey\n        });\n        var formatRoot = squarify(root, aspectRatio);\n        var nestIndex = this.state.nestIndex;\n        nestIndex.push(node);\n        this.setState({\n          formatRoot: formatRoot,\n          currentRoot: root,\n          nestIndex: nestIndex\n        });\n      }\n      if (onClick) {\n        onClick(node);\n      }\n    }\n  }, {\n    key: \"handleNestIndex\",\n    value: function handleNestIndex(node, i) {\n      var nestIndex = this.state.nestIndex;\n      var _this$props5 = this.props,\n        width = _this$props5.width,\n        height = _this$props5.height,\n        dataKey = _this$props5.dataKey,\n        aspectRatio = _this$props5.aspectRatio;\n      var root = computeNode({\n        depth: 0,\n        node: _objectSpread(_objectSpread({}, node), {}, {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        }),\n        index: 0,\n        valueKey: dataKey\n      });\n      var formatRoot = squarify(root, aspectRatio);\n      nestIndex = nestIndex.slice(0, i + 1);\n      this.setState({\n        formatRoot: formatRoot,\n        currentRoot: node,\n        nestIndex: nestIndex\n      });\n    }\n  }, {\n    key: \"renderItem\",\n    value: function renderItem(content, nodeProps, isLeaf) {\n      var _this2 = this;\n      var _this$props6 = this.props,\n        isAnimationActive = _this$props6.isAnimationActive,\n        animationBegin = _this$props6.animationBegin,\n        animationDuration = _this$props6.animationDuration,\n        animationEasing = _this$props6.animationEasing,\n        isUpdateAnimationActive = _this$props6.isUpdateAnimationActive,\n        type = _this$props6.type,\n        animationId = _this$props6.animationId,\n        colorPanel = _this$props6.colorPanel;\n      var isAnimationFinished = this.state.isAnimationFinished;\n      var width = nodeProps.width,\n        height = nodeProps.height,\n        x = nodeProps.x,\n        y = nodeProps.y,\n        depth = nodeProps.depth;\n      var translateX = parseInt(\"\".concat((Math.random() * 2 - 1) * width), 10);\n      var event = {};\n      if (isLeaf || type === 'nest') {\n        event = {\n          onMouseEnter: this.handleMouseEnter.bind(this, nodeProps),\n          onMouseLeave: this.handleMouseLeave.bind(this, nodeProps),\n          onClick: this.handleClick.bind(this, nodeProps)\n        };\n      }\n      if (!isAnimationActive) {\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.createElement(_container_Layer__WEBPACK_IMPORTED_MODULE_7__/* .Layer */ .W, event, this.constructor.renderContentItem(content, _objectSpread(_objectSpread({}, nodeProps), {}, {\n          isAnimationActive: false,\n          isUpdateAnimationActive: false,\n          width: width,\n          height: height,\n          x: x,\n          y: y\n        }), type, colorPanel));\n      }\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.createElement(react_smooth__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .Ay, {\n        begin: animationBegin,\n        duration: animationDuration,\n        isActive: isAnimationActive,\n        easing: animationEasing,\n        key: \"treemap-\".concat(animationId),\n        from: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        to: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        onAnimationStart: this.handleAnimationStart,\n        onAnimationEnd: this.handleAnimationEnd\n      }, function (_ref2) {\n        var currX = _ref2.x,\n          currY = _ref2.y,\n          currWidth = _ref2.width,\n          currHeight = _ref2.height;\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.createElement(react_smooth__WEBPACK_IMPORTED_MODULE_8__/* [\"default\"] */ .Ay, {\n          from: \"translate(\".concat(translateX, \"px, \").concat(translateX, \"px)\"),\n          to: \"translate(0, 0)\",\n          attributeName: \"transform\",\n          begin: animationBegin,\n          easing: animationEasing,\n          isActive: isAnimationActive,\n          duration: animationDuration\n        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.createElement(_container_Layer__WEBPACK_IMPORTED_MODULE_7__/* .Layer */ .W, event, function () {\n          // when animation Duration , only render depth=1 nodes\n          if (depth > 2 && !isAnimationFinished) {\n            return null;\n          }\n          return _this2.constructor.renderContentItem(content, _objectSpread(_objectSpread({}, nodeProps), {}, {\n            isAnimationActive: isAnimationActive,\n            isUpdateAnimationActive: !isUpdateAnimationActive,\n            width: currWidth,\n            height: currHeight,\n            x: currX,\n            y: currY\n          }), type, colorPanel);\n        }()));\n      });\n    }\n  }, {\n    key: \"renderNode\",\n    value: function renderNode(root, node) {\n      var _this3 = this;\n      var _this$props7 = this.props,\n        content = _this$props7.content,\n        type = _this$props7.type;\n      var nodeProps = _objectSpread(_objectSpread(_objectSpread({}, (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_5__/* .filterProps */ .J9)(this.props, false)), node), {}, {\n        root: root\n      });\n      var isLeaf = !node.children || !node.children.length;\n      var currentRoot = this.state.currentRoot;\n      var isCurrentRootChild = (currentRoot.children || []).filter(function (item) {\n        return item.depth === node.depth && item.name === node.name;\n      });\n      if (!isCurrentRootChild.length && root.depth && type === 'nest') {\n        return null;\n      }\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.createElement(_container_Layer__WEBPACK_IMPORTED_MODULE_7__/* .Layer */ .W, {\n        key: \"recharts-treemap-node-\".concat(nodeProps.x, \"-\").concat(nodeProps.y, \"-\").concat(nodeProps.name),\n        className: \"recharts-treemap-depth-\".concat(node.depth)\n      }, this.renderItem(content, nodeProps, isLeaf), node.children && node.children.length ? node.children.map(function (child) {\n        return _this3.renderNode(node, child);\n      }) : null);\n    }\n  }, {\n    key: \"renderAllNodes\",\n    value: function renderAllNodes() {\n      var formatRoot = this.state.formatRoot;\n      if (!formatRoot) {\n        return null;\n      }\n      return this.renderNode(formatRoot, formatRoot);\n    }\n  }, {\n    key: \"renderTooltip\",\n    value: function renderTooltip() {\n      var _this$props8 = this.props,\n        children = _this$props8.children,\n        nameKey = _this$props8.nameKey;\n      var tooltipItem = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_5__/* .findChildByType */ .BU)(children, _component_Tooltip__WEBPACK_IMPORTED_MODULE_6__/* .Tooltip */ .m);\n      if (!tooltipItem) {\n        return null;\n      }\n      var _this$props9 = this.props,\n        width = _this$props9.width,\n        height = _this$props9.height;\n      var _this$state = this.state,\n        isTooltipActive = _this$state.isTooltipActive,\n        activeNode = _this$state.activeNode;\n      var viewBox = {\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      };\n      var coordinate = activeNode ? {\n        x: activeNode.x + activeNode.width / 2,\n        y: activeNode.y + activeNode.height / 2\n      } : null;\n      var payload = isTooltipActive && activeNode ? [{\n        payload: activeNode,\n        name: (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_9__/* .getValueByDataKey */ .kr)(activeNode, nameKey, ''),\n        value: (0,_util_ChartUtils__WEBPACK_IMPORTED_MODULE_9__/* .getValueByDataKey */ .kr)(activeNode, NODE_VALUE_KEY)\n      }] : [];\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.cloneElement(tooltipItem, {\n        viewBox: viewBox,\n        active: isTooltipActive,\n        coordinate: coordinate,\n        label: '',\n        payload: payload\n      });\n    }\n\n    // render nest treemap\n  }, {\n    key: \"renderNestIndex\",\n    value: function renderNestIndex() {\n      var _this4 = this;\n      var _this$props10 = this.props,\n        nameKey = _this$props10.nameKey,\n        nestIndexContent = _this$props10.nestIndexContent;\n      var nestIndex = this.state.nestIndex;\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"div\", {\n        className: \"recharts-treemap-nest-index-wrapper\",\n        style: {\n          marginTop: '8px',\n          textAlign: 'center'\n        }\n      }, nestIndex.map(function (item, i) {\n        // TODO need to verify nameKey type\n        var name = lodash_get__WEBPACK_IMPORTED_MODULE_3___default()(item, nameKey, 'root');\n        var content = null;\n        if ( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.isValidElement(nestIndexContent)) {\n          content = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.cloneElement(nestIndexContent, item, i);\n        }\n        if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_1___default()(nestIndexContent)) {\n          content = nestIndexContent(item, i);\n        } else {\n          content = name;\n        }\n        return (\n          /*#__PURE__*/\n          // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions\n          react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"div\", {\n            onClick: _this4.handleNestIndex.bind(_this4, item, i),\n            key: \"nest-index-\".concat((0,_util_DataUtils__WEBPACK_IMPORTED_MODULE_10__/* .uniqueId */ .NF)()),\n            className: \"recharts-treemap-nest-index-box\",\n            style: {\n              cursor: 'pointer',\n              display: 'inline-block',\n              padding: '0 7px',\n              background: '#000',\n              color: '#fff',\n              marginRight: '3px'\n            }\n          }, content)\n        );\n      }));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!(0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_5__/* .validateWidthHeight */ .Me)(this)) {\n        return null;\n      }\n      var _this$props11 = this.props,\n        width = _this$props11.width,\n        height = _this$props11.height,\n        className = _this$props11.className,\n        style = _this$props11.style,\n        children = _this$props11.children,\n        type = _this$props11.type,\n        others = _objectWithoutProperties(_this$props11, _excluded);\n      var attrs = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_5__/* .filterProps */ .J9)(others, false);\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"div\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_11__/* [\"default\"] */ .A)('recharts-wrapper', className),\n        style: _objectSpread(_objectSpread({}, style), {}, {\n          position: 'relative',\n          cursor: 'default',\n          width: width,\n          height: height\n        }),\n        role: \"region\"\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.createElement(_container_Surface__WEBPACK_IMPORTED_MODULE_12__/* .Surface */ .u, _extends({}, attrs, {\n        width: width,\n        height: type === 'nest' ? height - 30 : height\n      }), this.renderAllNodes(), (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_5__/* .filterSvgElements */ .ux)(children)), this.renderTooltip(), type === 'nest' && this.renderNestIndex());\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.data !== prevState.prevData || nextProps.type !== prevState.prevType || nextProps.width !== prevState.prevWidth || nextProps.height !== prevState.prevHeight || nextProps.dataKey !== prevState.prevDataKey || nextProps.aspectRatio !== prevState.prevAspectRatio) {\n        var root = computeNode({\n          depth: 0,\n          node: {\n            children: nextProps.data,\n            x: 0,\n            y: 0,\n            width: nextProps.width,\n            height: nextProps.height\n          },\n          index: 0,\n          valueKey: nextProps.dataKey\n        });\n        var formatRoot = squarify(root, nextProps.aspectRatio);\n        return _objectSpread(_objectSpread({}, prevState), {}, {\n          formatRoot: formatRoot,\n          currentRoot: root,\n          nestIndex: [root],\n          prevAspectRatio: nextProps.aspectRatio,\n          prevData: nextProps.data,\n          prevWidth: nextProps.width,\n          prevHeight: nextProps.height,\n          prevDataKey: nextProps.dataKey,\n          prevType: nextProps.type\n        });\n      }\n      return null;\n    }\n  }, {\n    key: \"renderContentItem\",\n    value: function renderContentItem(content, nodeProps, type, colorPanel) {\n      if ( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.isValidElement(content)) {\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.cloneElement(content, nodeProps);\n      }\n      if (lodash_isFunction__WEBPACK_IMPORTED_MODULE_1___default()(content)) {\n        return content(nodeProps);\n      }\n      // optimize default shape\n      var x = nodeProps.x,\n        y = nodeProps.y,\n        width = nodeProps.width,\n        height = nodeProps.height,\n        index = nodeProps.index;\n      var arrow = null;\n      if (width > 10 && height > 10 && nodeProps.children && type === 'nest') {\n        arrow = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.createElement(_shape_Polygon__WEBPACK_IMPORTED_MODULE_13__/* .Polygon */ .t, {\n          points: [{\n            x: x + 2,\n            y: y + height / 2\n          }, {\n            x: x + 6,\n            y: y + height / 2 + 3\n          }, {\n            x: x + 2,\n            y: y + height / 2 + 6\n          }]\n        });\n      }\n      var text = null;\n      var nameSize = (0,_util_DOMUtils__WEBPACK_IMPORTED_MODULE_14__/* .getStringSize */ .Pu)(nodeProps.name);\n      if (width > 20 && height > 20 && nameSize.width < width && nameSize.height < height) {\n        text = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"text\", {\n          x: x + 8,\n          y: y + height / 2 + 7,\n          fontSize: 14\n        }, nodeProps.name);\n      }\n      var colors = colorPanel || _util_Constants__WEBPACK_IMPORTED_MODULE_15__/* .COLOR_PANEL */ .d;\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.createElement(\"g\", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_4__.createElement(_shape_Rectangle__WEBPACK_IMPORTED_MODULE_16__/* .Rectangle */ .M, _extends({\n        fill: nodeProps.depth < 2 ? colors[index % colors.length] : 'rgba(255,255,255,0)',\n        stroke: \"#fff\"\n      }, lodash_omit__WEBPACK_IMPORTED_MODULE_2___default()(nodeProps, 'children'), {\n        role: \"img\"\n      })), arrow, text);\n    }\n  }]);\n}(react__WEBPACK_IMPORTED_MODULE_4__.PureComponent);\n_defineProperty(Treemap, \"displayName\", 'Treemap');\n_defineProperty(Treemap, \"defaultProps\", {\n  aspectRatio: 0.5 * (1 + Math.sqrt(5)),\n  dataKey: 'value',\n  type: 'flat',\n  isAnimationActive: !_util_Global__WEBPACK_IMPORTED_MODULE_17__/* .Global */ .m.isSsr,\n  isUpdateAnimationActive: !_util_Global__WEBPACK_IMPORTED_MODULE_17__/* .Global */ .m.isSsr,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'linear'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzczNy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL215LXJlYWN0LWFwcC8uL25vZGVfbW9kdWxlcy9yZWNoYXJ0cy9lczYvY2hhcnQvVHJlZW1hcC5qcz9lZWRkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfZXhjbHVkZWQgPSBbXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImNsYXNzTmFtZVwiLCBcInN0eWxlXCIsIFwiY2hpbGRyZW5cIiwgXCJ0eXBlXCJdO1xuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7IHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7IH1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyB0cnkgeyB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IH0gY2F0Y2ggKHQpIHt9IHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IHJldHVybiAhIXQ7IH0pKCk7IH1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpOyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5pbXBvcnQgaXNOYW4gZnJvbSAnbG9kYXNoL2lzTmFOJztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJ2xvZGFzaC9pc0Z1bmN0aW9uJztcbmltcG9ydCBvbWl0IGZyb20gJ2xvZGFzaC9vbWl0JztcbmltcG9ydCBnZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4Jztcbi8qKlxuICogQGZpbGVPdmVydmlldyBUcmVlbWFwQ2hhcnRcbiAqL1xuaW1wb3J0IFJlYWN0LCB7IFB1cmVDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgU21vb3RoIGZyb20gJ3JlYWN0LXNtb290aCc7XG5pbXBvcnQgeyBUb29sdGlwIH0gZnJvbSAnLi4vY29tcG9uZW50L1Rvb2x0aXAnO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICcuLi9jb250YWluZXIvTGF5ZXInO1xuaW1wb3J0IHsgU3VyZmFjZSB9IGZyb20gJy4uL2NvbnRhaW5lci9TdXJmYWNlJztcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuLi9zaGFwZS9Qb2x5Z29uJztcbmltcG9ydCB7IFJlY3RhbmdsZSB9IGZyb20gJy4uL3NoYXBlL1JlY3RhbmdsZSc7XG5pbXBvcnQgeyBnZXRWYWx1ZUJ5RGF0YUtleSB9IGZyb20gJy4uL3V0aWwvQ2hhcnRVdGlscyc7XG5pbXBvcnQgeyBDT0xPUl9QQU5FTCB9IGZyb20gJy4uL3V0aWwvQ29uc3RhbnRzJztcbmltcG9ydCB7IHVuaXF1ZUlkIH0gZnJvbSAnLi4vdXRpbC9EYXRhVXRpbHMnO1xuaW1wb3J0IHsgZ2V0U3RyaW5nU2l6ZSB9IGZyb20gJy4uL3V0aWwvRE9NVXRpbHMnO1xuaW1wb3J0IHsgR2xvYmFsIH0gZnJvbSAnLi4vdXRpbC9HbG9iYWwnO1xuaW1wb3J0IHsgZmlsdGVyU3ZnRWxlbWVudHMsIGZpbmRDaGlsZEJ5VHlwZSwgdmFsaWRhdGVXaWR0aEhlaWdodCwgZmlsdGVyUHJvcHMgfSBmcm9tICcuLi91dGlsL1JlYWN0VXRpbHMnO1xudmFyIE5PREVfVkFMVUVfS0VZID0gJ3ZhbHVlJztcbnZhciBjb21wdXRlTm9kZSA9IGZ1bmN0aW9uIGNvbXB1dGVOb2RlKF9yZWYpIHtcbiAgdmFyIGRlcHRoID0gX3JlZi5kZXB0aCxcbiAgICBub2RlID0gX3JlZi5ub2RlLFxuICAgIGluZGV4ID0gX3JlZi5pbmRleCxcbiAgICB2YWx1ZUtleSA9IF9yZWYudmFsdWVLZXk7XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gIHZhciBjaGlsZERlcHRoID0gZGVwdGggKyAxO1xuICB2YXIgY29tcHV0ZWRDaGlsZHJlbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA/IGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICByZXR1cm4gY29tcHV0ZU5vZGUoe1xuICAgICAgZGVwdGg6IGNoaWxkRGVwdGgsXG4gICAgICBub2RlOiBjaGlsZCxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgdmFsdWVLZXk6IHZhbHVlS2V5XG4gICAgfSk7XG4gIH0pIDogbnVsbDtcbiAgdmFyIG5vZGVWYWx1ZTtcbiAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIG5vZGVWYWx1ZSA9IGNvbXB1dGVkQ2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGNoaWxkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgY2hpbGRbTk9ERV9WQUxVRV9LRVldO1xuICAgIH0sIDApO1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8gbmVlZCB0byB2ZXJpZnkgdmFsdWVLZXlcbiAgICBub2RlVmFsdWUgPSBpc05hbihub2RlW3ZhbHVlS2V5XSkgfHwgbm9kZVt2YWx1ZUtleV0gPD0gMCA/IDAgOiBub2RlW3ZhbHVlS2V5XTtcbiAgfVxuICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBub2RlKSwge30sIF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KHtcbiAgICBjaGlsZHJlbjogY29tcHV0ZWRDaGlsZHJlblxuICB9LCBOT0RFX1ZBTFVFX0tFWSwgbm9kZVZhbHVlKSwgXCJkZXB0aFwiLCBkZXB0aCksIFwiaW5kZXhcIiwgaW5kZXgpKTtcbn07XG52YXIgZmlsdGVyUmVjdCA9IGZ1bmN0aW9uIGZpbHRlclJlY3Qobm9kZSkge1xuICByZXR1cm4ge1xuICAgIHg6IG5vZGUueCxcbiAgICB5OiBub2RlLnksXG4gICAgd2lkdGg6IG5vZGUud2lkdGgsXG4gICAgaGVpZ2h0OiBub2RlLmhlaWdodFxuICB9O1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgYXJlYSBmb3IgZWFjaCBjaGlsZCBiYXNlZCBvbiB2YWx1ZSAmIHNjYWxlLlxudmFyIGdldEFyZWFPZkNoaWxkcmVuID0gZnVuY3Rpb24gZ2V0QXJlYU9mQ2hpbGRyZW4oY2hpbGRyZW4sIGFyZWFWYWx1ZVJhdGlvKSB7XG4gIHZhciByYXRpbyA9IGFyZWFWYWx1ZVJhdGlvIDwgMCA/IDAgOiBhcmVhVmFsdWVSYXRpbztcbiAgcmV0dXJuIGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICB2YXIgYXJlYSA9IGNoaWxkW05PREVfVkFMVUVfS0VZXSAqIHJhdGlvO1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNoaWxkKSwge30sIHtcbiAgICAgIGFyZWE6IGlzTmFuKGFyZWEpIHx8IGFyZWEgPD0gMCA/IDAgOiBhcmVhXG4gICAgfSk7XG4gIH0pO1xufTtcblxuLy8gQ29tcHV0ZXMgdGhlIHNjb3JlIGZvciB0aGUgc3BlY2lmaWVkIHJvdywgYXMgdGhlIHdvcnN0IGFzcGVjdCByYXRpby5cbnZhciBnZXRXb3JzdFNjb3JlID0gZnVuY3Rpb24gZ2V0V29yc3RTY29yZShyb3csIHBhcmVudFNpemUsIGFzcGVjdFJhdGlvKSB7XG4gIHZhciBwYXJlbnRBcmVhID0gcGFyZW50U2l6ZSAqIHBhcmVudFNpemU7XG4gIHZhciByb3dBcmVhID0gcm93LmFyZWEgKiByb3cuYXJlYTtcbiAgdmFyIF9yb3ckcmVkdWNlID0gcm93LnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBjaGlsZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiBNYXRoLm1pbihyZXN1bHQubWluLCBjaGlsZC5hcmVhKSxcbiAgICAgICAgbWF4OiBNYXRoLm1heChyZXN1bHQubWF4LCBjaGlsZC5hcmVhKVxuICAgICAgfTtcbiAgICB9LCB7XG4gICAgICBtaW46IEluZmluaXR5LFxuICAgICAgbWF4OiAwXG4gICAgfSksXG4gICAgbWluID0gX3JvdyRyZWR1Y2UubWluLFxuICAgIG1heCA9IF9yb3ckcmVkdWNlLm1heDtcbiAgcmV0dXJuIHJvd0FyZWEgPyBNYXRoLm1heChwYXJlbnRBcmVhICogbWF4ICogYXNwZWN0UmF0aW8gLyByb3dBcmVhLCByb3dBcmVhIC8gKHBhcmVudEFyZWEgKiBtaW4gKiBhc3BlY3RSYXRpbykpIDogSW5maW5pdHk7XG59O1xudmFyIGhvcml6b250YWxQb3NpdGlvbiA9IGZ1bmN0aW9uIGhvcml6b250YWxQb3NpdGlvbihyb3csIHBhcmVudFNpemUsIHBhcmVudFJlY3QsIGlzRmx1c2gpIHtcbiAgdmFyIHJvd0hlaWdodCA9IHBhcmVudFNpemUgPyBNYXRoLnJvdW5kKHJvdy5hcmVhIC8gcGFyZW50U2l6ZSkgOiAwO1xuICBpZiAoaXNGbHVzaCB8fCByb3dIZWlnaHQgPiBwYXJlbnRSZWN0LmhlaWdodCkge1xuICAgIHJvd0hlaWdodCA9IHBhcmVudFJlY3QuaGVpZ2h0O1xuICB9XG4gIHZhciBjdXJYID0gcGFyZW50UmVjdC54O1xuICB2YXIgY2hpbGQ7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb3cubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaGlsZCA9IHJvd1tpXTtcbiAgICBjaGlsZC54ID0gY3VyWDtcbiAgICBjaGlsZC55ID0gcGFyZW50UmVjdC55O1xuICAgIGNoaWxkLmhlaWdodCA9IHJvd0hlaWdodDtcbiAgICBjaGlsZC53aWR0aCA9IE1hdGgubWluKHJvd0hlaWdodCA/IE1hdGgucm91bmQoY2hpbGQuYXJlYSAvIHJvd0hlaWdodCkgOiAwLCBwYXJlbnRSZWN0LnggKyBwYXJlbnRSZWN0LndpZHRoIC0gY3VyWCk7XG4gICAgY3VyWCArPSBjaGlsZC53aWR0aDtcbiAgfVxuICAvLyBhZGQgdGhlIHJlbWFpbiB4IHRvIHRoZSBsYXN0IG9uZSBvZiByb3dcbiAgY2hpbGQud2lkdGggKz0gcGFyZW50UmVjdC54ICsgcGFyZW50UmVjdC53aWR0aCAtIGN1clg7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudFJlY3QpLCB7fSwge1xuICAgIHk6IHBhcmVudFJlY3QueSArIHJvd0hlaWdodCxcbiAgICBoZWlnaHQ6IHBhcmVudFJlY3QuaGVpZ2h0IC0gcm93SGVpZ2h0XG4gIH0pO1xufTtcbnZhciB2ZXJ0aWNhbFBvc2l0aW9uID0gZnVuY3Rpb24gdmVydGljYWxQb3NpdGlvbihyb3csIHBhcmVudFNpemUsIHBhcmVudFJlY3QsIGlzRmx1c2gpIHtcbiAgdmFyIHJvd1dpZHRoID0gcGFyZW50U2l6ZSA/IE1hdGgucm91bmQocm93LmFyZWEgLyBwYXJlbnRTaXplKSA6IDA7XG4gIGlmIChpc0ZsdXNoIHx8IHJvd1dpZHRoID4gcGFyZW50UmVjdC53aWR0aCkge1xuICAgIHJvd1dpZHRoID0gcGFyZW50UmVjdC53aWR0aDtcbiAgfVxuICB2YXIgY3VyWSA9IHBhcmVudFJlY3QueTtcbiAgdmFyIGNoaWxkO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm93Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2hpbGQgPSByb3dbaV07XG4gICAgY2hpbGQueCA9IHBhcmVudFJlY3QueDtcbiAgICBjaGlsZC55ID0gY3VyWTtcbiAgICBjaGlsZC53aWR0aCA9IHJvd1dpZHRoO1xuICAgIGNoaWxkLmhlaWdodCA9IE1hdGgubWluKHJvd1dpZHRoID8gTWF0aC5yb3VuZChjaGlsZC5hcmVhIC8gcm93V2lkdGgpIDogMCwgcGFyZW50UmVjdC55ICsgcGFyZW50UmVjdC5oZWlnaHQgLSBjdXJZKTtcbiAgICBjdXJZICs9IGNoaWxkLmhlaWdodDtcbiAgfVxuICBpZiAoY2hpbGQpIHtcbiAgICBjaGlsZC5oZWlnaHQgKz0gcGFyZW50UmVjdC55ICsgcGFyZW50UmVjdC5oZWlnaHQgLSBjdXJZO1xuICB9XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBhcmVudFJlY3QpLCB7fSwge1xuICAgIHg6IHBhcmVudFJlY3QueCArIHJvd1dpZHRoLFxuICAgIHdpZHRoOiBwYXJlbnRSZWN0LndpZHRoIC0gcm93V2lkdGhcbiAgfSk7XG59O1xudmFyIHBvc2l0aW9uID0gZnVuY3Rpb24gcG9zaXRpb24ocm93LCBwYXJlbnRTaXplLCBwYXJlbnRSZWN0LCBpc0ZsdXNoKSB7XG4gIGlmIChwYXJlbnRTaXplID09PSBwYXJlbnRSZWN0LndpZHRoKSB7XG4gICAgcmV0dXJuIGhvcml6b250YWxQb3NpdGlvbihyb3csIHBhcmVudFNpemUsIHBhcmVudFJlY3QsIGlzRmx1c2gpO1xuICB9XG4gIHJldHVybiB2ZXJ0aWNhbFBvc2l0aW9uKHJvdywgcGFyZW50U2l6ZSwgcGFyZW50UmVjdCwgaXNGbHVzaCk7XG59O1xuXG4vLyBSZWN1cnNpdmVseSBhcnJhbmdlcyB0aGUgc3BlY2lmaWVkIG5vZGUncyBjaGlsZHJlbiBpbnRvIHNxdWFyaWZpZWQgcm93cy5cbnZhciBzcXVhcmlmeSA9IGZ1bmN0aW9uIHNxdWFyaWZ5KG5vZGUsIGFzcGVjdFJhdGlvKSB7XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgcmVjdCA9IGZpbHRlclJlY3Qobm9kZSk7XG4gICAgLy8gbWF5YmUgYSBidWdcbiAgICB2YXIgcm93ID0gW107XG4gICAgdmFyIGJlc3QgPSBJbmZpbml0eTsgLy8gdGhlIGJlc3Qgcm93IHNjb3JlIHNvIGZhclxuICAgIHZhciBjaGlsZCwgc2NvcmU7IC8vIHRoZSBjdXJyZW50IHJvdyBzY29yZVxuICAgIHZhciBzaXplID0gTWF0aC5taW4ocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpOyAvLyBpbml0aWFsIG9yaWVudGF0aW9uXG4gICAgdmFyIHNjYWxlQ2hpbGRyZW4gPSBnZXRBcmVhT2ZDaGlsZHJlbihjaGlsZHJlbiwgcmVjdC53aWR0aCAqIHJlY3QuaGVpZ2h0IC8gbm9kZVtOT0RFX1ZBTFVFX0tFWV0pO1xuICAgIHZhciB0ZW1wQ2hpbGRyZW4gPSBzY2FsZUNoaWxkcmVuLnNsaWNlKCk7XG4gICAgcm93LmFyZWEgPSAwO1xuICAgIHdoaWxlICh0ZW1wQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgLy8gcm93IGZpcnN0XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgIHJvdy5wdXNoKGNoaWxkID0gdGVtcENoaWxkcmVuWzBdKTtcbiAgICAgIHJvdy5hcmVhICs9IGNoaWxkLmFyZWE7XG4gICAgICBzY29yZSA9IGdldFdvcnN0U2NvcmUocm93LCBzaXplLCBhc3BlY3RSYXRpbyk7XG4gICAgICBpZiAoc2NvcmUgPD0gYmVzdCkge1xuICAgICAgICAvLyBjb250aW51ZSB3aXRoIHRoaXMgb3JpZW50YXRpb25cbiAgICAgICAgdGVtcENoaWxkcmVuLnNoaWZ0KCk7XG4gICAgICAgIGJlc3QgPSBzY29yZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFib3J0LCBhbmQgdHJ5IGEgZGlmZmVyZW50IG9yaWVudGF0aW9uXG4gICAgICAgIHJvdy5hcmVhIC09IHJvdy5wb3AoKS5hcmVhO1xuICAgICAgICByZWN0ID0gcG9zaXRpb24ocm93LCBzaXplLCByZWN0LCBmYWxzZSk7XG4gICAgICAgIHNpemUgPSBNYXRoLm1pbihyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgIHJvdy5sZW5ndGggPSByb3cuYXJlYSA9IDA7XG4gICAgICAgIGJlc3QgPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJvdy5sZW5ndGgpIHtcbiAgICAgIHJlY3QgPSBwb3NpdGlvbihyb3csIHNpemUsIHJlY3QsIHRydWUpO1xuICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbm9kZSksIHt9LCB7XG4gICAgICBjaGlsZHJlbjogc2NhbGVDaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIHNxdWFyaWZ5KGMsIGFzcGVjdFJhdGlvKTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xudmFyIGRlZmF1bHRTdGF0ZSA9IHtcbiAgaXNUb29sdGlwQWN0aXZlOiBmYWxzZSxcbiAgaXNBbmltYXRpb25GaW5pc2hlZDogZmFsc2UsXG4gIGFjdGl2ZU5vZGU6IG51bGwsXG4gIGZvcm1hdFJvb3Q6IG51bGwsXG4gIGN1cnJlbnRSb290OiBudWxsLFxuICBuZXN0SW5kZXg6IFtdXG59O1xuZXhwb3J0IHZhciBUcmVlbWFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUHVyZUNvbXBvbmVudCkge1xuICBmdW5jdGlvbiBUcmVlbWFwKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJlZW1hcCk7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgVHJlZW1hcCwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic3RhdGVcIiwgX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdFN0YXRlKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhhbmRsZUFuaW1hdGlvbkVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb25BbmltYXRpb25FbmQgPSBfdGhpcy5wcm9wcy5vbkFuaW1hdGlvbkVuZDtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNBbmltYXRpb25GaW5pc2hlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoaXNGdW5jdGlvbihvbkFuaW1hdGlvbkVuZCkpIHtcbiAgICAgICAgb25BbmltYXRpb25FbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFuZGxlQW5pbWF0aW9uU3RhcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG9uQW5pbWF0aW9uU3RhcnQgPSBfdGhpcy5wcm9wcy5vbkFuaW1hdGlvblN0YXJ0O1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc0FuaW1hdGlvbkZpbmlzaGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBpZiAoaXNGdW5jdGlvbihvbkFuaW1hdGlvblN0YXJ0KSkge1xuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhUcmVlbWFwLCBfUHVyZUNvbXBvbmVudCk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVHJlZW1hcCwgW3tcbiAgICBrZXk6IFwiaGFuZGxlTW91c2VFbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3VzZUVudGVyKG5vZGUsIGUpIHtcbiAgICAgIGUucGVyc2lzdCgpO1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgb25Nb3VzZUVudGVyID0gX3RoaXMkcHJvcHMub25Nb3VzZUVudGVyLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIHRvb2x0aXBJdGVtID0gZmluZENoaWxkQnlUeXBlKGNoaWxkcmVuLCBUb29sdGlwKTtcbiAgICAgIGlmICh0b29sdGlwSXRlbSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpc1Rvb2x0aXBBY3RpdmU6IHRydWUsXG4gICAgICAgICAgYWN0aXZlTm9kZTogbm9kZVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG9uTW91c2VFbnRlcikge1xuICAgICAgICAgICAgb25Nb3VzZUVudGVyKG5vZGUsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG9uTW91c2VFbnRlcikge1xuICAgICAgICBvbk1vdXNlRW50ZXIobm9kZSwgZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZU1vdXNlTGVhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW91c2VMZWF2ZShub2RlLCBlKSB7XG4gICAgICBlLnBlcnNpc3QoKTtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBvbk1vdXNlTGVhdmUgPSBfdGhpcyRwcm9wczIub25Nb3VzZUxlYXZlLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzMi5jaGlsZHJlbjtcbiAgICAgIHZhciB0b29sdGlwSXRlbSA9IGZpbmRDaGlsZEJ5VHlwZShjaGlsZHJlbiwgVG9vbHRpcCk7XG4gICAgICBpZiAodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaXNUb29sdGlwQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICBhY3RpdmVOb2RlOiBudWxsXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAob25Nb3VzZUxlYXZlKSB7XG4gICAgICAgICAgICBvbk1vdXNlTGVhdmUobm9kZSwgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob25Nb3VzZUxlYXZlKSB7XG4gICAgICAgIG9uTW91c2VMZWF2ZShub2RlLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2xpY2sobm9kZSkge1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgIG9uQ2xpY2sgPSBfdGhpcyRwcm9wczMub25DbGljayxcbiAgICAgICAgdHlwZSA9IF90aGlzJHByb3BzMy50eXBlO1xuICAgICAgaWYgKHR5cGUgPT09ICduZXN0JyAmJiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM0LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzNC5oZWlnaHQsXG4gICAgICAgICAgZGF0YUtleSA9IF90aGlzJHByb3BzNC5kYXRhS2V5LFxuICAgICAgICAgIGFzcGVjdFJhdGlvID0gX3RoaXMkcHJvcHM0LmFzcGVjdFJhdGlvO1xuICAgICAgICB2YXIgcm9vdCA9IGNvbXB1dGVOb2RlKHtcbiAgICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgICBub2RlOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG5vZGUpLCB7fSwge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgIHZhbHVlS2V5OiBkYXRhS2V5XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZm9ybWF0Um9vdCA9IHNxdWFyaWZ5KHJvb3QsIGFzcGVjdFJhdGlvKTtcbiAgICAgICAgdmFyIG5lc3RJbmRleCA9IHRoaXMuc3RhdGUubmVzdEluZGV4O1xuICAgICAgICBuZXN0SW5kZXgucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgZm9ybWF0Um9vdDogZm9ybWF0Um9vdCxcbiAgICAgICAgICBjdXJyZW50Um9vdDogcm9vdCxcbiAgICAgICAgICBuZXN0SW5kZXg6IG5lc3RJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgIG9uQ2xpY2sobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZU5lc3RJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVOZXN0SW5kZXgobm9kZSwgaSkge1xuICAgICAgdmFyIG5lc3RJbmRleCA9IHRoaXMuc3RhdGUubmVzdEluZGV4O1xuICAgICAgdmFyIF90aGlzJHByb3BzNSA9IHRoaXMucHJvcHMsXG4gICAgICAgIHdpZHRoID0gX3RoaXMkcHJvcHM1LndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczUuaGVpZ2h0LFxuICAgICAgICBkYXRhS2V5ID0gX3RoaXMkcHJvcHM1LmRhdGFLZXksXG4gICAgICAgIGFzcGVjdFJhdGlvID0gX3RoaXMkcHJvcHM1LmFzcGVjdFJhdGlvO1xuICAgICAgdmFyIHJvb3QgPSBjb21wdXRlTm9kZSh7XG4gICAgICAgIGRlcHRoOiAwLFxuICAgICAgICBub2RlOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG5vZGUpLCB7fSwge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSksXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICB2YWx1ZUtleTogZGF0YUtleVxuICAgICAgfSk7XG4gICAgICB2YXIgZm9ybWF0Um9vdCA9IHNxdWFyaWZ5KHJvb3QsIGFzcGVjdFJhdGlvKTtcbiAgICAgIG5lc3RJbmRleCA9IG5lc3RJbmRleC5zbGljZSgwLCBpICsgMSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZm9ybWF0Um9vdDogZm9ybWF0Um9vdCxcbiAgICAgICAgY3VycmVudFJvb3Q6IG5vZGUsXG4gICAgICAgIG5lc3RJbmRleDogbmVzdEluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVySXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJJdGVtKGNvbnRlbnQsIG5vZGVQcm9wcywgaXNMZWFmKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczYgPSB0aGlzLnByb3BzLFxuICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzNi5pc0FuaW1hdGlvbkFjdGl2ZSxcbiAgICAgICAgYW5pbWF0aW9uQmVnaW4gPSBfdGhpcyRwcm9wczYuYW5pbWF0aW9uQmVnaW4sXG4gICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uID0gX3RoaXMkcHJvcHM2LmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICBhbmltYXRpb25FYXNpbmcgPSBfdGhpcyRwcm9wczYuYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICBpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZSA9IF90aGlzJHByb3BzNi5pc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZSxcbiAgICAgICAgdHlwZSA9IF90aGlzJHByb3BzNi50eXBlLFxuICAgICAgICBhbmltYXRpb25JZCA9IF90aGlzJHByb3BzNi5hbmltYXRpb25JZCxcbiAgICAgICAgY29sb3JQYW5lbCA9IF90aGlzJHByb3BzNi5jb2xvclBhbmVsO1xuICAgICAgdmFyIGlzQW5pbWF0aW9uRmluaXNoZWQgPSB0aGlzLnN0YXRlLmlzQW5pbWF0aW9uRmluaXNoZWQ7XG4gICAgICB2YXIgd2lkdGggPSBub2RlUHJvcHMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IG5vZGVQcm9wcy5oZWlnaHQsXG4gICAgICAgIHggPSBub2RlUHJvcHMueCxcbiAgICAgICAgeSA9IG5vZGVQcm9wcy55LFxuICAgICAgICBkZXB0aCA9IG5vZGVQcm9wcy5kZXB0aDtcbiAgICAgIHZhciB0cmFuc2xhdGVYID0gcGFyc2VJbnQoXCJcIi5jb25jYXQoKE1hdGgucmFuZG9tKCkgKiAyIC0gMSkgKiB3aWR0aCksIDEwKTtcbiAgICAgIHZhciBldmVudCA9IHt9O1xuICAgICAgaWYgKGlzTGVhZiB8fCB0eXBlID09PSAnbmVzdCcpIHtcbiAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLmhhbmRsZU1vdXNlRW50ZXIuYmluZCh0aGlzLCBub2RlUHJvcHMpLFxuICAgICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5oYW5kbGVNb3VzZUxlYXZlLmJpbmQodGhpcywgbm9kZVByb3BzKSxcbiAgICAgICAgICBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLmJpbmQodGhpcywgbm9kZVByb3BzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FuaW1hdGlvbkFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGF5ZXIsIGV2ZW50LCB0aGlzLmNvbnN0cnVjdG9yLnJlbmRlckNvbnRlbnRJdGVtKGNvbnRlbnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbm9kZVByb3BzKSwge30sIHtcbiAgICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgaXNVcGRhdGVBbmltYXRpb25BY3RpdmU6IGZhbHNlLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSksIHR5cGUsIGNvbG9yUGFuZWwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTbW9vdGgsIHtcbiAgICAgICAgYmVnaW46IGFuaW1hdGlvbkJlZ2luLFxuICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgIGlzQWN0aXZlOiBpc0FuaW1hdGlvbkFjdGl2ZSxcbiAgICAgICAgZWFzaW5nOiBhbmltYXRpb25FYXNpbmcsXG4gICAgICAgIGtleTogXCJ0cmVlbWFwLVwiLmNvbmNhdChhbmltYXRpb25JZCksXG4gICAgICAgIGZyb206IHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIHRvOiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9LFxuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0OiB0aGlzLmhhbmRsZUFuaW1hdGlvblN0YXJ0LFxuICAgICAgICBvbkFuaW1hdGlvbkVuZDogdGhpcy5oYW5kbGVBbmltYXRpb25FbmRcbiAgICAgIH0sIGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgY3VyclggPSBfcmVmMi54LFxuICAgICAgICAgIGN1cnJZID0gX3JlZjIueSxcbiAgICAgICAgICBjdXJyV2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgICBjdXJySGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU21vb3RoLCB7XG4gICAgICAgICAgZnJvbTogXCJ0cmFuc2xhdGUoXCIuY29uY2F0KHRyYW5zbGF0ZVgsIFwicHgsIFwiKS5jb25jYXQodHJhbnNsYXRlWCwgXCJweClcIiksXG4gICAgICAgICAgdG86IFwidHJhbnNsYXRlKDAsIDApXCIsXG4gICAgICAgICAgYXR0cmlidXRlTmFtZTogXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICBiZWdpbjogYW5pbWF0aW9uQmVnaW4sXG4gICAgICAgICAgZWFzaW5nOiBhbmltYXRpb25FYXNpbmcsXG4gICAgICAgICAgaXNBY3RpdmU6IGlzQW5pbWF0aW9uQWN0aXZlLFxuICAgICAgICAgIGR1cmF0aW9uOiBhbmltYXRpb25EdXJhdGlvblxuICAgICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMYXllciwgZXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyB3aGVuIGFuaW1hdGlvbiBEdXJhdGlvbiAsIG9ubHkgcmVuZGVyIGRlcHRoPTEgbm9kZXNcbiAgICAgICAgICBpZiAoZGVwdGggPiAyICYmICFpc0FuaW1hdGlvbkZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5jb25zdHJ1Y3Rvci5yZW5kZXJDb250ZW50SXRlbShjb250ZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG5vZGVQcm9wcyksIHt9LCB7XG4gICAgICAgICAgICBpc0FuaW1hdGlvbkFjdGl2ZTogaXNBbmltYXRpb25BY3RpdmUsXG4gICAgICAgICAgICBpc1VwZGF0ZUFuaW1hdGlvbkFjdGl2ZTogIWlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlLFxuICAgICAgICAgICAgd2lkdGg6IGN1cnJXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY3VyckhlaWdodCxcbiAgICAgICAgICAgIHg6IGN1cnJYLFxuICAgICAgICAgICAgeTogY3VycllcbiAgICAgICAgICB9KSwgdHlwZSwgY29sb3JQYW5lbCk7XG4gICAgICAgIH0oKSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlck5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTm9kZShyb290LCBub2RlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBfdGhpcyRwcm9wczcgPSB0aGlzLnByb3BzLFxuICAgICAgICBjb250ZW50ID0gX3RoaXMkcHJvcHM3LmNvbnRlbnQsXG4gICAgICAgIHR5cGUgPSBfdGhpcyRwcm9wczcudHlwZTtcbiAgICAgIHZhciBub2RlUHJvcHMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZmlsdGVyUHJvcHModGhpcy5wcm9wcywgZmFsc2UpKSwgbm9kZSksIHt9LCB7XG4gICAgICAgIHJvb3Q6IHJvb3RcbiAgICAgIH0pO1xuICAgICAgdmFyIGlzTGVhZiA9ICFub2RlLmNoaWxkcmVuIHx8ICFub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIHZhciBjdXJyZW50Um9vdCA9IHRoaXMuc3RhdGUuY3VycmVudFJvb3Q7XG4gICAgICB2YXIgaXNDdXJyZW50Um9vdENoaWxkID0gKGN1cnJlbnRSb290LmNoaWxkcmVuIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uZGVwdGggPT09IG5vZGUuZGVwdGggJiYgaXRlbS5uYW1lID09PSBub2RlLm5hbWU7XG4gICAgICB9KTtcbiAgICAgIGlmICghaXNDdXJyZW50Um9vdENoaWxkLmxlbmd0aCAmJiByb290LmRlcHRoICYmIHR5cGUgPT09ICduZXN0Jykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMYXllciwge1xuICAgICAgICBrZXk6IFwicmVjaGFydHMtdHJlZW1hcC1ub2RlLVwiLmNvbmNhdChub2RlUHJvcHMueCwgXCItXCIpLmNvbmNhdChub2RlUHJvcHMueSwgXCItXCIpLmNvbmNhdChub2RlUHJvcHMubmFtZSksXG4gICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy10cmVlbWFwLWRlcHRoLVwiLmNvbmNhdChub2RlLmRlcHRoKVxuICAgICAgfSwgdGhpcy5yZW5kZXJJdGVtKGNvbnRlbnQsIG5vZGVQcm9wcywgaXNMZWFmKSwgbm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA/IG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnJlbmRlck5vZGUobm9kZSwgY2hpbGQpO1xuICAgICAgfSkgOiBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQWxsTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQWxsTm9kZXMoKSB7XG4gICAgICB2YXIgZm9ybWF0Um9vdCA9IHRoaXMuc3RhdGUuZm9ybWF0Um9vdDtcbiAgICAgIGlmICghZm9ybWF0Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlck5vZGUoZm9ybWF0Um9vdCwgZm9ybWF0Um9vdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclRvb2x0aXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVG9vbHRpcCgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczggPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzOC5jaGlsZHJlbixcbiAgICAgICAgbmFtZUtleSA9IF90aGlzJHByb3BzOC5uYW1lS2V5O1xuICAgICAgdmFyIHRvb2x0aXBJdGVtID0gZmluZENoaWxkQnlUeXBlKGNoaWxkcmVuLCBUb29sdGlwKTtcbiAgICAgIGlmICghdG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX3RoaXMkcHJvcHM5ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczkud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJHByb3BzOS5oZWlnaHQ7XG4gICAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICBpc1Rvb2x0aXBBY3RpdmUgPSBfdGhpcyRzdGF0ZS5pc1Rvb2x0aXBBY3RpdmUsXG4gICAgICAgIGFjdGl2ZU5vZGUgPSBfdGhpcyRzdGF0ZS5hY3RpdmVOb2RlO1xuICAgICAgdmFyIHZpZXdCb3ggPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH07XG4gICAgICB2YXIgY29vcmRpbmF0ZSA9IGFjdGl2ZU5vZGUgPyB7XG4gICAgICAgIHg6IGFjdGl2ZU5vZGUueCArIGFjdGl2ZU5vZGUud2lkdGggLyAyLFxuICAgICAgICB5OiBhY3RpdmVOb2RlLnkgKyBhY3RpdmVOb2RlLmhlaWdodCAvIDJcbiAgICAgIH0gOiBudWxsO1xuICAgICAgdmFyIHBheWxvYWQgPSBpc1Rvb2x0aXBBY3RpdmUgJiYgYWN0aXZlTm9kZSA/IFt7XG4gICAgICAgIHBheWxvYWQ6IGFjdGl2ZU5vZGUsXG4gICAgICAgIG5hbWU6IGdldFZhbHVlQnlEYXRhS2V5KGFjdGl2ZU5vZGUsIG5hbWVLZXksICcnKSxcbiAgICAgICAgdmFsdWU6IGdldFZhbHVlQnlEYXRhS2V5KGFjdGl2ZU5vZGUsIE5PREVfVkFMVUVfS0VZKVxuICAgICAgfV0gOiBbXTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KHRvb2x0aXBJdGVtLCB7XG4gICAgICAgIHZpZXdCb3g6IHZpZXdCb3gsXG4gICAgICAgIGFjdGl2ZTogaXNUb29sdGlwQWN0aXZlLFxuICAgICAgICBjb29yZGluYXRlOiBjb29yZGluYXRlLFxuICAgICAgICBsYWJlbDogJycsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHJlbmRlciBuZXN0IHRyZWVtYXBcbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJOZXN0SW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTmVzdEluZGV4KCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMxMCA9IHRoaXMucHJvcHMsXG4gICAgICAgIG5hbWVLZXkgPSBfdGhpcyRwcm9wczEwLm5hbWVLZXksXG4gICAgICAgIG5lc3RJbmRleENvbnRlbnQgPSBfdGhpcyRwcm9wczEwLm5lc3RJbmRleENvbnRlbnQ7XG4gICAgICB2YXIgbmVzdEluZGV4ID0gdGhpcy5zdGF0ZS5uZXN0SW5kZXg7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwicmVjaGFydHMtdHJlZW1hcC1uZXN0LWluZGV4LXdyYXBwZXJcIixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBtYXJnaW5Ub3A6ICc4cHgnLFxuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcidcbiAgICAgICAgfVxuICAgICAgfSwgbmVzdEluZGV4Lm1hcChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAvLyBUT0RPIG5lZWQgdG8gdmVyaWZ5IG5hbWVLZXkgdHlwZVxuICAgICAgICB2YXIgbmFtZSA9IGdldChpdGVtLCBuYW1lS2V5LCAncm9vdCcpO1xuICAgICAgICB2YXIgY29udGVudCA9IG51bGw7XG4gICAgICAgIGlmICggLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KG5lc3RJbmRleENvbnRlbnQpKSB7XG4gICAgICAgICAgY29udGVudCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQobmVzdEluZGV4Q29udGVudCwgaXRlbSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24obmVzdEluZGV4Q29udGVudCkpIHtcbiAgICAgICAgICBjb250ZW50ID0gbmVzdEluZGV4Q29udGVudChpdGVtLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZW50ID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvY2xpY2stZXZlbnRzLWhhdmUta2V5LWV2ZW50cywganN4LWExMXkvbm8tc3RhdGljLWVsZW1lbnQtaW50ZXJhY3Rpb25zXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBvbkNsaWNrOiBfdGhpczQuaGFuZGxlTmVzdEluZGV4LmJpbmQoX3RoaXM0LCBpdGVtLCBpKSxcbiAgICAgICAgICAgIGtleTogXCJuZXN0LWluZGV4LVwiLmNvbmNhdCh1bmlxdWVJZCgpKSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJyZWNoYXJ0cy10cmVlbWFwLW5lc3QtaW5kZXgtYm94XCIsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICAgIHBhZGRpbmc6ICcwIDdweCcsXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjMDAwJyxcbiAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQ6ICczcHgnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgY29udGVudClcbiAgICAgICAgKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICghdmFsaWRhdGVXaWR0aEhlaWdodCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBfdGhpcyRwcm9wczExID0gdGhpcy5wcm9wcyxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRwcm9wczExLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRwcm9wczExLmhlaWdodCxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMxMS5jbGFzc05hbWUsXG4gICAgICAgIHN0eWxlID0gX3RoaXMkcHJvcHMxMS5zdHlsZSxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczExLmNoaWxkcmVuLFxuICAgICAgICB0eXBlID0gX3RoaXMkcHJvcHMxMS50eXBlLFxuICAgICAgICBvdGhlcnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHMxMSwgX2V4Y2x1ZGVkKTtcbiAgICAgIHZhciBhdHRycyA9IGZpbHRlclByb3BzKG90aGVycywgZmFsc2UpO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbHN4KCdyZWNoYXJ0cy13cmFwcGVyJywgY2xhc3NOYW1lKSxcbiAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3R5bGUpLCB7fSwge1xuICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KSxcbiAgICAgICAgcm9sZTogXCJyZWdpb25cIlxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU3VyZmFjZSwgX2V4dGVuZHMoe30sIGF0dHJzLCB7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0eXBlID09PSAnbmVzdCcgPyBoZWlnaHQgLSAzMCA6IGhlaWdodFxuICAgICAgfSksIHRoaXMucmVuZGVyQWxsTm9kZXMoKSwgZmlsdGVyU3ZnRWxlbWVudHMoY2hpbGRyZW4pKSwgdGhpcy5yZW5kZXJUb29sdGlwKCksIHR5cGUgPT09ICduZXN0JyAmJiB0aGlzLnJlbmRlck5lc3RJbmRleCgpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmRhdGEgIT09IHByZXZTdGF0ZS5wcmV2RGF0YSB8fCBuZXh0UHJvcHMudHlwZSAhPT0gcHJldlN0YXRlLnByZXZUeXBlIHx8IG5leHRQcm9wcy53aWR0aCAhPT0gcHJldlN0YXRlLnByZXZXaWR0aCB8fCBuZXh0UHJvcHMuaGVpZ2h0ICE9PSBwcmV2U3RhdGUucHJldkhlaWdodCB8fCBuZXh0UHJvcHMuZGF0YUtleSAhPT0gcHJldlN0YXRlLnByZXZEYXRhS2V5IHx8IG5leHRQcm9wcy5hc3BlY3RSYXRpbyAhPT0gcHJldlN0YXRlLnByZXZBc3BlY3RSYXRpbykge1xuICAgICAgICB2YXIgcm9vdCA9IGNvbXB1dGVOb2RlKHtcbiAgICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICBjaGlsZHJlbjogbmV4dFByb3BzLmRhdGEsXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiBuZXh0UHJvcHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IG5leHRQcm9wcy5oZWlnaHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgIHZhbHVlS2V5OiBuZXh0UHJvcHMuZGF0YUtleVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZvcm1hdFJvb3QgPSBzcXVhcmlmeShyb290LCBuZXh0UHJvcHMuYXNwZWN0UmF0aW8pO1xuICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcmV2U3RhdGUpLCB7fSwge1xuICAgICAgICAgIGZvcm1hdFJvb3Q6IGZvcm1hdFJvb3QsXG4gICAgICAgICAgY3VycmVudFJvb3Q6IHJvb3QsXG4gICAgICAgICAgbmVzdEluZGV4OiBbcm9vdF0sXG4gICAgICAgICAgcHJldkFzcGVjdFJhdGlvOiBuZXh0UHJvcHMuYXNwZWN0UmF0aW8sXG4gICAgICAgICAgcHJldkRhdGE6IG5leHRQcm9wcy5kYXRhLFxuICAgICAgICAgIHByZXZXaWR0aDogbmV4dFByb3BzLndpZHRoLFxuICAgICAgICAgIHByZXZIZWlnaHQ6IG5leHRQcm9wcy5oZWlnaHQsXG4gICAgICAgICAgcHJldkRhdGFLZXk6IG5leHRQcm9wcy5kYXRhS2V5LFxuICAgICAgICAgIHByZXZUeXBlOiBuZXh0UHJvcHMudHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJDb250ZW50SXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDb250ZW50SXRlbShjb250ZW50LCBub2RlUHJvcHMsIHR5cGUsIGNvbG9yUGFuZWwpIHtcbiAgICAgIGlmICggLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGNvbnRlbnQpKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KGNvbnRlbnQsIG5vZGVQcm9wcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNGdW5jdGlvbihjb250ZW50KSkge1xuICAgICAgICByZXR1cm4gY29udGVudChub2RlUHJvcHMpO1xuICAgICAgfVxuICAgICAgLy8gb3B0aW1pemUgZGVmYXVsdCBzaGFwZVxuICAgICAgdmFyIHggPSBub2RlUHJvcHMueCxcbiAgICAgICAgeSA9IG5vZGVQcm9wcy55LFxuICAgICAgICB3aWR0aCA9IG5vZGVQcm9wcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gbm9kZVByb3BzLmhlaWdodCxcbiAgICAgICAgaW5kZXggPSBub2RlUHJvcHMuaW5kZXg7XG4gICAgICB2YXIgYXJyb3cgPSBudWxsO1xuICAgICAgaWYgKHdpZHRoID4gMTAgJiYgaGVpZ2h0ID4gMTAgJiYgbm9kZVByb3BzLmNoaWxkcmVuICYmIHR5cGUgPT09ICduZXN0Jykge1xuICAgICAgICBhcnJvdyA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvbHlnb24sIHtcbiAgICAgICAgICBwb2ludHM6IFt7XG4gICAgICAgICAgICB4OiB4ICsgMixcbiAgICAgICAgICAgIHk6IHkgKyBoZWlnaHQgLyAyXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogeCArIDYsXG4gICAgICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMiArIDNcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiB4ICsgMixcbiAgICAgICAgICAgIHk6IHkgKyBoZWlnaHQgLyAyICsgNlxuICAgICAgICAgIH1dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIHRleHQgPSBudWxsO1xuICAgICAgdmFyIG5hbWVTaXplID0gZ2V0U3RyaW5nU2l6ZShub2RlUHJvcHMubmFtZSk7XG4gICAgICBpZiAod2lkdGggPiAyMCAmJiBoZWlnaHQgPiAyMCAmJiBuYW1lU2l6ZS53aWR0aCA8IHdpZHRoICYmIG5hbWVTaXplLmhlaWdodCA8IGhlaWdodCkge1xuICAgICAgICB0ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIsIHtcbiAgICAgICAgICB4OiB4ICsgOCxcbiAgICAgICAgICB5OiB5ICsgaGVpZ2h0IC8gMiArIDcsXG4gICAgICAgICAgZm9udFNpemU6IDE0XG4gICAgICAgIH0sIG5vZGVQcm9wcy5uYW1lKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2xvcnMgPSBjb2xvclBhbmVsIHx8IENPTE9SX1BBTkVMO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWN0YW5nbGUsIF9leHRlbmRzKHtcbiAgICAgICAgZmlsbDogbm9kZVByb3BzLmRlcHRoIDwgMiA/IGNvbG9yc1tpbmRleCAlIGNvbG9ycy5sZW5ndGhdIDogJ3JnYmEoMjU1LDI1NSwyNTUsMCknLFxuICAgICAgICBzdHJva2U6IFwiI2ZmZlwiXG4gICAgICB9LCBvbWl0KG5vZGVQcm9wcywgJ2NoaWxkcmVuJyksIHtcbiAgICAgICAgcm9sZTogXCJpbWdcIlxuICAgICAgfSkpLCBhcnJvdywgdGV4dCk7XG4gICAgfVxuICB9XSk7XG59KFB1cmVDb21wb25lbnQpO1xuX2RlZmluZVByb3BlcnR5KFRyZWVtYXAsIFwiZGlzcGxheU5hbWVcIiwgJ1RyZWVtYXAnKTtcbl9kZWZpbmVQcm9wZXJ0eShUcmVlbWFwLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIGFzcGVjdFJhdGlvOiAwLjUgKiAoMSArIE1hdGguc3FydCg1KSksXG4gIGRhdGFLZXk6ICd2YWx1ZScsXG4gIHR5cGU6ICdmbGF0JyxcbiAgaXNBbmltYXRpb25BY3RpdmU6ICFHbG9iYWwuaXNTc3IsXG4gIGlzVXBkYXRlQW5pbWF0aW9uQWN0aXZlOiAhR2xvYmFsLmlzU3NyLFxuICBhbmltYXRpb25CZWdpbjogMCxcbiAgYW5pbWF0aW9uRHVyYXRpb246IDE1MDAsXG4gIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcidcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3737\n");

/***/ }),

/***/ 6435:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   r: () => (/* binding */ SunburstChart)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6540);\n/* harmony import */ var victory_vendor_d3_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6502);\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4164);\n/* harmony import */ var _util_ReactUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4501);\n/* harmony import */ var _container_Surface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9303);\n/* harmony import */ var _container_Layer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6069);\n/* harmony import */ var _shape_Sector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8522);\n/* harmony import */ var _component_Text__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(261);\n/* harmony import */ var _util_PolarUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4040);\n/* harmony import */ var _component_Tooltip__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(2149);\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n\n\n\n\n\n\n\n\n\nvar defaultTextProps = {\n  fontWeight: 'bold',\n  paintOrder: 'stroke fill',\n  fontSize: '.75rem',\n  stroke: '#FFF',\n  fill: 'black',\n  pointerEvents: 'none'\n};\nfunction getMaxDepthOf(node) {\n  if (!node.children || node.children.length === 0) return 1;\n\n  // Calculate depth for each child and find the maximum\n  var childDepths = node.children.map(function (d) {\n    return getMaxDepthOf(d);\n  });\n  return 1 + Math.max.apply(Math, _toConsumableArray(childDepths));\n}\nvar SunburstChart = function SunburstChart(_ref) {\n  var className = _ref.className,\n    data = _ref.data,\n    children = _ref.children,\n    width = _ref.width,\n    height = _ref.height,\n    _ref$padding = _ref.padding,\n    padding = _ref$padding === void 0 ? 2 : _ref$padding,\n    _ref$dataKey = _ref.dataKey,\n    dataKey = _ref$dataKey === void 0 ? 'value' : _ref$dataKey,\n    _ref$ringPadding = _ref.ringPadding,\n    ringPadding = _ref$ringPadding === void 0 ? 2 : _ref$ringPadding,\n    _ref$innerRadius = _ref.innerRadius,\n    innerRadius = _ref$innerRadius === void 0 ? 50 : _ref$innerRadius,\n    _ref$fill = _ref.fill,\n    fill = _ref$fill === void 0 ? '#333' : _ref$fill,\n    _ref$stroke = _ref.stroke,\n    stroke = _ref$stroke === void 0 ? '#FFF' : _ref$stroke,\n    _ref$textOptions = _ref.textOptions,\n    textOptions = _ref$textOptions === void 0 ? defaultTextProps : _ref$textOptions,\n    _ref$outerRadius = _ref.outerRadius,\n    outerRadius = _ref$outerRadius === void 0 ? Math.min(width, height) / 2 : _ref$outerRadius,\n    _ref$cx = _ref.cx,\n    cx = _ref$cx === void 0 ? width / 2 : _ref$cx,\n    _ref$cy = _ref.cy,\n    cy = _ref$cy === void 0 ? height / 2 : _ref$cy,\n    _ref$startAngle = _ref.startAngle,\n    startAngle = _ref$startAngle === void 0 ? 0 : _ref$startAngle,\n    _ref$endAngle = _ref.endAngle,\n    endAngle = _ref$endAngle === void 0 ? 360 : _ref$endAngle,\n    onClick = _ref.onClick,\n    onMouseEnter = _ref.onMouseEnter,\n    onMouseLeave = _ref.onMouseLeave;\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    isTooltipActive = _useState2[0],\n    setIsTooltipActive = _useState2[1];\n  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null),\n    _useState4 = _slicedToArray(_useState3, 2),\n    activeNode = _useState4[0],\n    setActiveNode = _useState4[1];\n  var rScale = (0,victory_vendor_d3_scale__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)([0, data[dataKey]], [0, endAngle]);\n  var treeDepth = getMaxDepthOf(data);\n  var thickness = (outerRadius - innerRadius) / treeDepth;\n  var sectors = [];\n  var positions = new Map([]);\n\n  // event handlers\n  function handleMouseEnter(node, e) {\n    if (onMouseEnter) onMouseEnter(node, e);\n    setActiveNode(node);\n    setIsTooltipActive(true);\n  }\n  function handleMouseLeave(node, e) {\n    if (onMouseLeave) onMouseLeave(node, e);\n    setActiveNode(null);\n    setIsTooltipActive(false);\n  }\n  function handleClick(node) {\n    if (onClick) onClick(node);\n  }\n\n  // recursively add nodes for each data point and its children\n  function drawArcs(childNodes, options) {\n    var radius = options.radius,\n      innerR = options.innerR,\n      initialAngle = options.initialAngle,\n      childColor = options.childColor;\n    var currentAngle = initialAngle;\n    if (!childNodes) return; // base case: no children of this node\n\n    childNodes.forEach(function (d) {\n      var _ref2, _d$fill;\n      var arcLength = rScale(d[dataKey]);\n      var start = currentAngle;\n      // color priority - if there's a color on the individual point use that, otherwise use parent color or default\n      var fillColor = (_ref2 = (_d$fill = d === null || d === void 0 ? void 0 : d.fill) !== null && _d$fill !== void 0 ? _d$fill : childColor) !== null && _ref2 !== void 0 ? _ref2 : fill;\n      var _polarToCartesian = (0,_util_PolarUtils__WEBPACK_IMPORTED_MODULE_2__/* .polarToCartesian */ .IZ)(0, 0, innerR + radius / 2, -(start + arcLength - arcLength / 2)),\n        textX = _polarToCartesian.x,\n        textY = _polarToCartesian.y;\n      currentAngle += arcLength;\n      sectors.push(\n      /*#__PURE__*/\n      // TODO: Missing key warning. Can we use `key={d.name}`?\n      react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n        \"aria-label\": d.name,\n        tabIndex: 0\n      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shape_Sector__WEBPACK_IMPORTED_MODULE_3__/* .Sector */ .h, {\n        onClick: function onClick() {\n          return handleClick(d);\n        },\n        onMouseEnter: function onMouseEnter(e) {\n          return handleMouseEnter(d, e);\n        },\n        onMouseLeave: function onMouseLeave(e) {\n          return handleMouseLeave(d, e);\n        },\n        fill: fillColor,\n        stroke: stroke,\n        strokeWidth: padding,\n        startAngle: start,\n        endAngle: start + arcLength,\n        innerRadius: innerR,\n        outerRadius: innerR + radius,\n        cx: cx,\n        cy: cy\n      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_component_Text__WEBPACK_IMPORTED_MODULE_4__/* .Text */ .E, _extends({}, textOptions, {\n        alignmentBaseline: \"middle\",\n        textAnchor: \"middle\",\n        x: textX + cx,\n        y: cy - textY\n      }), d[dataKey])));\n      var _polarToCartesian2 = (0,_util_PolarUtils__WEBPACK_IMPORTED_MODULE_2__/* .polarToCartesian */ .IZ)(cx, cy, innerR + radius / 2, start),\n        tooltipX = _polarToCartesian2.x,\n        tooltipY = _polarToCartesian2.y;\n      positions.set(d.name, {\n        x: tooltipX,\n        y: tooltipY\n      });\n      return drawArcs(d.children, {\n        radius: radius,\n        innerR: innerR + radius + ringPadding,\n        initialAngle: start,\n        childColor: fillColor\n      });\n    });\n  }\n  drawArcs(data.children, {\n    radius: thickness,\n    innerR: innerRadius,\n    initialAngle: startAngle\n  });\n  var layerClass = (0,clsx__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A)('recharts-sunburst', className);\n  function renderTooltip() {\n    var tooltipComponent = (0,_util_ReactUtils__WEBPACK_IMPORTED_MODULE_6__/* .findChildByType */ .BU)([children], _component_Tooltip__WEBPACK_IMPORTED_MODULE_7__/* .Tooltip */ .m);\n    if (!tooltipComponent || !activeNode) return null;\n    var viewBox = {\n      x: 0,\n      y: 0,\n      width: width,\n      height: height\n    };\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(tooltipComponent, {\n      viewBox: viewBox,\n      coordinate: positions.get(activeNode.name),\n      payload: [activeNode],\n      active: isTooltipActive\n    });\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    className: (0,clsx__WEBPACK_IMPORTED_MODULE_5__/* [\"default\"] */ .A)('recharts-wrapper', className),\n    style: {\n      position: 'relative',\n      width: width,\n      height: height\n    },\n    role: \"region\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_container_Surface__WEBPACK_IMPORTED_MODULE_8__/* .Surface */ .u, {\n    width: width,\n    height: height\n  }, children, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_container_Layer__WEBPACK_IMPORTED_MODULE_9__/* .Layer */ .W, {\n    className: layerClass\n  }, sectors)), renderTooltip());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQzNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1yZWFjdC1hcHAvLi9ub2RlX21vZHVsZXMvcmVjaGFydHMvZXM2L2NoYXJ0L1N1bmJ1cnN0Q2hhcnQuanM/NjY0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHNjYWxlTGluZWFyIH0gZnJvbSAndmljdG9yeS12ZW5kb3IvZDMtc2NhbGUnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyBmaW5kQ2hpbGRCeVR5cGUgfSBmcm9tICcuLi91dGlsL1JlYWN0VXRpbHMnO1xuaW1wb3J0IHsgU3VyZmFjZSB9IGZyb20gJy4uL2NvbnRhaW5lci9TdXJmYWNlJztcbmltcG9ydCB7IExheWVyIH0gZnJvbSAnLi4vY29udGFpbmVyL0xheWVyJztcbmltcG9ydCB7IFNlY3RvciB9IGZyb20gJy4uL3NoYXBlL1NlY3Rvcic7XG5pbXBvcnQgeyBUZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50L1RleHQnO1xuaW1wb3J0IHsgcG9sYXJUb0NhcnRlc2lhbiB9IGZyb20gJy4uL3V0aWwvUG9sYXJVdGlscyc7XG5pbXBvcnQgeyBUb29sdGlwIH0gZnJvbSAnLi4vY29tcG9uZW50L1Rvb2x0aXAnO1xudmFyIGRlZmF1bHRUZXh0UHJvcHMgPSB7XG4gIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgcGFpbnRPcmRlcjogJ3N0cm9rZSBmaWxsJyxcbiAgZm9udFNpemU6ICcuNzVyZW0nLFxuICBzdHJva2U6ICcjRkZGJyxcbiAgZmlsbDogJ2JsYWNrJyxcbiAgcG9pbnRlckV2ZW50czogJ25vbmUnXG59O1xuZnVuY3Rpb24gZ2V0TWF4RGVwdGhPZihub2RlKSB7XG4gIGlmICghbm9kZS5jaGlsZHJlbiB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDE7XG5cbiAgLy8gQ2FsY3VsYXRlIGRlcHRoIGZvciBlYWNoIGNoaWxkIGFuZCBmaW5kIHRoZSBtYXhpbXVtXG4gIHZhciBjaGlsZERlcHRocyA9IG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGdldE1heERlcHRoT2YoZCk7XG4gIH0pO1xuICByZXR1cm4gMSArIE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShjaGlsZERlcHRocykpO1xufVxuZXhwb3J0IHZhciBTdW5idXJzdENoYXJ0ID0gZnVuY3Rpb24gU3VuYnVyc3RDaGFydChfcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICBkYXRhID0gX3JlZi5kYXRhLFxuICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgX3JlZiRwYWRkaW5nID0gX3JlZi5wYWRkaW5nLFxuICAgIHBhZGRpbmcgPSBfcmVmJHBhZGRpbmcgPT09IHZvaWQgMCA/IDIgOiBfcmVmJHBhZGRpbmcsXG4gICAgX3JlZiRkYXRhS2V5ID0gX3JlZi5kYXRhS2V5LFxuICAgIGRhdGFLZXkgPSBfcmVmJGRhdGFLZXkgPT09IHZvaWQgMCA/ICd2YWx1ZScgOiBfcmVmJGRhdGFLZXksXG4gICAgX3JlZiRyaW5nUGFkZGluZyA9IF9yZWYucmluZ1BhZGRpbmcsXG4gICAgcmluZ1BhZGRpbmcgPSBfcmVmJHJpbmdQYWRkaW5nID09PSB2b2lkIDAgPyAyIDogX3JlZiRyaW5nUGFkZGluZyxcbiAgICBfcmVmJGlubmVyUmFkaXVzID0gX3JlZi5pbm5lclJhZGl1cyxcbiAgICBpbm5lclJhZGl1cyA9IF9yZWYkaW5uZXJSYWRpdXMgPT09IHZvaWQgMCA/IDUwIDogX3JlZiRpbm5lclJhZGl1cyxcbiAgICBfcmVmJGZpbGwgPSBfcmVmLmZpbGwsXG4gICAgZmlsbCA9IF9yZWYkZmlsbCA9PT0gdm9pZCAwID8gJyMzMzMnIDogX3JlZiRmaWxsLFxuICAgIF9yZWYkc3Ryb2tlID0gX3JlZi5zdHJva2UsXG4gICAgc3Ryb2tlID0gX3JlZiRzdHJva2UgPT09IHZvaWQgMCA/ICcjRkZGJyA6IF9yZWYkc3Ryb2tlLFxuICAgIF9yZWYkdGV4dE9wdGlvbnMgPSBfcmVmLnRleHRPcHRpb25zLFxuICAgIHRleHRPcHRpb25zID0gX3JlZiR0ZXh0T3B0aW9ucyA9PT0gdm9pZCAwID8gZGVmYXVsdFRleHRQcm9wcyA6IF9yZWYkdGV4dE9wdGlvbnMsXG4gICAgX3JlZiRvdXRlclJhZGl1cyA9IF9yZWYub3V0ZXJSYWRpdXMsXG4gICAgb3V0ZXJSYWRpdXMgPSBfcmVmJG91dGVyUmFkaXVzID09PSB2b2lkIDAgPyBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDIgOiBfcmVmJG91dGVyUmFkaXVzLFxuICAgIF9yZWYkY3ggPSBfcmVmLmN4LFxuICAgIGN4ID0gX3JlZiRjeCA9PT0gdm9pZCAwID8gd2lkdGggLyAyIDogX3JlZiRjeCxcbiAgICBfcmVmJGN5ID0gX3JlZi5jeSxcbiAgICBjeSA9IF9yZWYkY3kgPT09IHZvaWQgMCA/IGhlaWdodCAvIDIgOiBfcmVmJGN5LFxuICAgIF9yZWYkc3RhcnRBbmdsZSA9IF9yZWYuc3RhcnRBbmdsZSxcbiAgICBzdGFydEFuZ2xlID0gX3JlZiRzdGFydEFuZ2xlID09PSB2b2lkIDAgPyAwIDogX3JlZiRzdGFydEFuZ2xlLFxuICAgIF9yZWYkZW5kQW5nbGUgPSBfcmVmLmVuZEFuZ2xlLFxuICAgIGVuZEFuZ2xlID0gX3JlZiRlbmRBbmdsZSA9PT0gdm9pZCAwID8gMzYwIDogX3JlZiRlbmRBbmdsZSxcbiAgICBvbkNsaWNrID0gX3JlZi5vbkNsaWNrLFxuICAgIG9uTW91c2VFbnRlciA9IF9yZWYub25Nb3VzZUVudGVyLFxuICAgIG9uTW91c2VMZWF2ZSA9IF9yZWYub25Nb3VzZUxlYXZlO1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoZmFsc2UpLFxuICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgIGlzVG9vbHRpcEFjdGl2ZSA9IF91c2VTdGF0ZTJbMF0sXG4gICAgc2V0SXNUb29sdGlwQWN0aXZlID0gX3VzZVN0YXRlMlsxXTtcbiAgdmFyIF91c2VTdGF0ZTMgPSB1c2VTdGF0ZShudWxsKSxcbiAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMiksXG4gICAgYWN0aXZlTm9kZSA9IF91c2VTdGF0ZTRbMF0sXG4gICAgc2V0QWN0aXZlTm9kZSA9IF91c2VTdGF0ZTRbMV07XG4gIHZhciByU2NhbGUgPSBzY2FsZUxpbmVhcihbMCwgZGF0YVtkYXRhS2V5XV0sIFswLCBlbmRBbmdsZV0pO1xuICB2YXIgdHJlZURlcHRoID0gZ2V0TWF4RGVwdGhPZihkYXRhKTtcbiAgdmFyIHRoaWNrbmVzcyA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIHRyZWVEZXB0aDtcbiAgdmFyIHNlY3RvcnMgPSBbXTtcbiAgdmFyIHBvc2l0aW9ucyA9IG5ldyBNYXAoW10pO1xuXG4gIC8vIGV2ZW50IGhhbmRsZXJzXG4gIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRW50ZXIobm9kZSwgZSkge1xuICAgIGlmIChvbk1vdXNlRW50ZXIpIG9uTW91c2VFbnRlcihub2RlLCBlKTtcbiAgICBzZXRBY3RpdmVOb2RlKG5vZGUpO1xuICAgIHNldElzVG9vbHRpcEFjdGl2ZSh0cnVlKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZUxlYXZlKG5vZGUsIGUpIHtcbiAgICBpZiAob25Nb3VzZUxlYXZlKSBvbk1vdXNlTGVhdmUobm9kZSwgZSk7XG4gICAgc2V0QWN0aXZlTm9kZShudWxsKTtcbiAgICBzZXRJc1Rvb2x0aXBBY3RpdmUoZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKG5vZGUpIHtcbiAgICBpZiAob25DbGljaykgb25DbGljayhub2RlKTtcbiAgfVxuXG4gIC8vIHJlY3Vyc2l2ZWx5IGFkZCBub2RlcyBmb3IgZWFjaCBkYXRhIHBvaW50IGFuZCBpdHMgY2hpbGRyZW5cbiAgZnVuY3Rpb24gZHJhd0FyY3MoY2hpbGROb2Rlcywgb3B0aW9ucykge1xuICAgIHZhciByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyxcbiAgICAgIGlubmVyUiA9IG9wdGlvbnMuaW5uZXJSLFxuICAgICAgaW5pdGlhbEFuZ2xlID0gb3B0aW9ucy5pbml0aWFsQW5nbGUsXG4gICAgICBjaGlsZENvbG9yID0gb3B0aW9ucy5jaGlsZENvbG9yO1xuICAgIHZhciBjdXJyZW50QW5nbGUgPSBpbml0aWFsQW5nbGU7XG4gICAgaWYgKCFjaGlsZE5vZGVzKSByZXR1cm47IC8vIGJhc2UgY2FzZTogbm8gY2hpbGRyZW4gb2YgdGhpcyBub2RlXG5cbiAgICBjaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIHZhciBfcmVmMiwgX2QkZmlsbDtcbiAgICAgIHZhciBhcmNMZW5ndGggPSByU2NhbGUoZFtkYXRhS2V5XSk7XG4gICAgICB2YXIgc3RhcnQgPSBjdXJyZW50QW5nbGU7XG4gICAgICAvLyBjb2xvciBwcmlvcml0eSAtIGlmIHRoZXJlJ3MgYSBjb2xvciBvbiB0aGUgaW5kaXZpZHVhbCBwb2ludCB1c2UgdGhhdCwgb3RoZXJ3aXNlIHVzZSBwYXJlbnQgY29sb3Igb3IgZGVmYXVsdFxuICAgICAgdmFyIGZpbGxDb2xvciA9IChfcmVmMiA9IChfZCRmaWxsID0gZCA9PT0gbnVsbCB8fCBkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkLmZpbGwpICE9PSBudWxsICYmIF9kJGZpbGwgIT09IHZvaWQgMCA/IF9kJGZpbGwgOiBjaGlsZENvbG9yKSAhPT0gbnVsbCAmJiBfcmVmMiAhPT0gdm9pZCAwID8gX3JlZjIgOiBmaWxsO1xuICAgICAgdmFyIF9wb2xhclRvQ2FydGVzaWFuID0gcG9sYXJUb0NhcnRlc2lhbigwLCAwLCBpbm5lclIgKyByYWRpdXMgLyAyLCAtKHN0YXJ0ICsgYXJjTGVuZ3RoIC0gYXJjTGVuZ3RoIC8gMikpLFxuICAgICAgICB0ZXh0WCA9IF9wb2xhclRvQ2FydGVzaWFuLngsXG4gICAgICAgIHRleHRZID0gX3BvbGFyVG9DYXJ0ZXNpYW4ueTtcbiAgICAgIGN1cnJlbnRBbmdsZSArPSBhcmNMZW5ndGg7XG4gICAgICBzZWN0b3JzLnB1c2goXG4gICAgICAvKiNfX1BVUkVfXyovXG4gICAgICAvLyBUT0RPOiBNaXNzaW5nIGtleSB3YXJuaW5nLiBDYW4gd2UgdXNlIGBrZXk9e2QubmFtZX1gP1xuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge1xuICAgICAgICBcImFyaWEtbGFiZWxcIjogZC5uYW1lLFxuICAgICAgICB0YWJJbmRleDogMFxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoU2VjdG9yLCB7XG4gICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUNsaWNrKGQpO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRW50ZXI6IGZ1bmN0aW9uIG9uTW91c2VFbnRlcihlKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZU1vdXNlRW50ZXIoZCwgZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VMZWF2ZTogZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGUpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlTW91c2VMZWF2ZShkLCBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbDogZmlsbENvbG9yLFxuICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHBhZGRpbmcsXG4gICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0LFxuICAgICAgICBlbmRBbmdsZTogc3RhcnQgKyBhcmNMZW5ndGgsXG4gICAgICAgIGlubmVyUmFkaXVzOiBpbm5lclIsXG4gICAgICAgIG91dGVyUmFkaXVzOiBpbm5lclIgKyByYWRpdXMsXG4gICAgICAgIGN4OiBjeCxcbiAgICAgICAgY3k6IGN5XG4gICAgICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dCwgX2V4dGVuZHMoe30sIHRleHRPcHRpb25zLCB7XG4gICAgICAgIGFsaWdubWVudEJhc2VsaW5lOiBcIm1pZGRsZVwiLFxuICAgICAgICB0ZXh0QW5jaG9yOiBcIm1pZGRsZVwiLFxuICAgICAgICB4OiB0ZXh0WCArIGN4LFxuICAgICAgICB5OiBjeSAtIHRleHRZXG4gICAgICB9KSwgZFtkYXRhS2V5XSkpKTtcbiAgICAgIHZhciBfcG9sYXJUb0NhcnRlc2lhbjIgPSBwb2xhclRvQ2FydGVzaWFuKGN4LCBjeSwgaW5uZXJSICsgcmFkaXVzIC8gMiwgc3RhcnQpLFxuICAgICAgICB0b29sdGlwWCA9IF9wb2xhclRvQ2FydGVzaWFuMi54LFxuICAgICAgICB0b29sdGlwWSA9IF9wb2xhclRvQ2FydGVzaWFuMi55O1xuICAgICAgcG9zaXRpb25zLnNldChkLm5hbWUsIHtcbiAgICAgICAgeDogdG9vbHRpcFgsXG4gICAgICAgIHk6IHRvb2x0aXBZXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkcmF3QXJjcyhkLmNoaWxkcmVuLCB7XG4gICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICBpbm5lclI6IGlubmVyUiArIHJhZGl1cyArIHJpbmdQYWRkaW5nLFxuICAgICAgICBpbml0aWFsQW5nbGU6IHN0YXJ0LFxuICAgICAgICBjaGlsZENvbG9yOiBmaWxsQ29sb3JcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGRyYXdBcmNzKGRhdGEuY2hpbGRyZW4sIHtcbiAgICByYWRpdXM6IHRoaWNrbmVzcyxcbiAgICBpbm5lclI6IGlubmVyUmFkaXVzLFxuICAgIGluaXRpYWxBbmdsZTogc3RhcnRBbmdsZVxuICB9KTtcbiAgdmFyIGxheWVyQ2xhc3MgPSBjbHN4KCdyZWNoYXJ0cy1zdW5idXJzdCcsIGNsYXNzTmFtZSk7XG4gIGZ1bmN0aW9uIHJlbmRlclRvb2x0aXAoKSB7XG4gICAgdmFyIHRvb2x0aXBDb21wb25lbnQgPSBmaW5kQ2hpbGRCeVR5cGUoW2NoaWxkcmVuXSwgVG9vbHRpcCk7XG4gICAgaWYgKCF0b29sdGlwQ29tcG9uZW50IHx8ICFhY3RpdmVOb2RlKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgdmlld0JveCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KHRvb2x0aXBDb21wb25lbnQsIHtcbiAgICAgIHZpZXdCb3g6IHZpZXdCb3gsXG4gICAgICBjb29yZGluYXRlOiBwb3NpdGlvbnMuZ2V0KGFjdGl2ZU5vZGUubmFtZSksXG4gICAgICBwYXlsb2FkOiBbYWN0aXZlTm9kZV0sXG4gICAgICBhY3RpdmU6IGlzVG9vbHRpcEFjdGl2ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbHN4KCdyZWNoYXJ0cy13cmFwcGVyJywgY2xhc3NOYW1lKSxcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH0sXG4gICAgcm9sZTogXCJyZWdpb25cIlxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTdXJmYWNlLCB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH0sIGNoaWxkcmVuLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMYXllciwge1xuICAgIGNsYXNzTmFtZTogbGF5ZXJDbGFzc1xuICB9LCBzZWN0b3JzKSksIHJlbmRlclRvb2x0aXAoKSk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6435\n");

/***/ }),

/***/ 9853:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   t: () => (/* binding */ ScatterChart)\n/* harmony export */ });\n/* harmony import */ var _generateCategoricalChart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3264);\n/* harmony import */ var _cartesian_Scatter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4799);\n/* harmony import */ var _cartesian_XAxis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7984);\n/* harmony import */ var _cartesian_YAxis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3495);\n/* harmony import */ var _cartesian_ZAxis__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1658);\n/* harmony import */ var _util_CartesianUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5894);\n/**\n * @fileOverview Scatter Chart\n */\n\n\n\n\n\n\nvar ScatterChart = (0,_generateCategoricalChart__WEBPACK_IMPORTED_MODULE_0__/* .generateCategoricalChart */ .gu)({\n  chartName: 'ScatterChart',\n  GraphicalChild: _cartesian_Scatter__WEBPACK_IMPORTED_MODULE_1__/* .Scatter */ .X,\n  defaultTooltipEventType: 'item',\n  validateTooltipEventTypes: ['item'],\n  axisComponents: [{\n    axisType: 'xAxis',\n    AxisComp: _cartesian_XAxis__WEBPACK_IMPORTED_MODULE_2__/* .XAxis */ .W\n  }, {\n    axisType: 'yAxis',\n    AxisComp: _cartesian_YAxis__WEBPACK_IMPORTED_MODULE_3__/* .YAxis */ .h\n  }, {\n    axisType: 'zAxis',\n    AxisComp: _cartesian_ZAxis__WEBPACK_IMPORTED_MODULE_4__/* .ZAxis */ .K\n  }],\n  formatAxisMap: _util_CartesianUtils__WEBPACK_IMPORTED_MODULE_5__/* .formatAxisMap */ .pr\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg1My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktcmVhY3QtYXBwLy4vbm9kZV9tb2R1bGVzL3JlY2hhcnRzL2VzNi9jaGFydC9TY2F0dGVyQ2hhcnQuanM/MzI2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlT3ZlcnZpZXcgU2NhdHRlciBDaGFydFxuICovXG5pbXBvcnQgeyBnZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQgfSBmcm9tICcuL2dlbmVyYXRlQ2F0ZWdvcmljYWxDaGFydCc7XG5pbXBvcnQgeyBTY2F0dGVyIH0gZnJvbSAnLi4vY2FydGVzaWFuL1NjYXR0ZXInO1xuaW1wb3J0IHsgWEF4aXMgfSBmcm9tICcuLi9jYXJ0ZXNpYW4vWEF4aXMnO1xuaW1wb3J0IHsgWUF4aXMgfSBmcm9tICcuLi9jYXJ0ZXNpYW4vWUF4aXMnO1xuaW1wb3J0IHsgWkF4aXMgfSBmcm9tICcuLi9jYXJ0ZXNpYW4vWkF4aXMnO1xuaW1wb3J0IHsgZm9ybWF0QXhpc01hcCB9IGZyb20gJy4uL3V0aWwvQ2FydGVzaWFuVXRpbHMnO1xuZXhwb3J0IHZhciBTY2F0dGVyQ2hhcnQgPSBnZW5lcmF0ZUNhdGVnb3JpY2FsQ2hhcnQoe1xuICBjaGFydE5hbWU6ICdTY2F0dGVyQ2hhcnQnLFxuICBHcmFwaGljYWxDaGlsZDogU2NhdHRlcixcbiAgZGVmYXVsdFRvb2x0aXBFdmVudFR5cGU6ICdpdGVtJyxcbiAgdmFsaWRhdGVUb29sdGlwRXZlbnRUeXBlczogWydpdGVtJ10sXG4gIGF4aXNDb21wb25lbnRzOiBbe1xuICAgIGF4aXNUeXBlOiAneEF4aXMnLFxuICAgIEF4aXNDb21wOiBYQXhpc1xuICB9LCB7XG4gICAgYXhpc1R5cGU6ICd5QXhpcycsXG4gICAgQXhpc0NvbXA6IFlBeGlzXG4gIH0sIHtcbiAgICBheGlzVHlwZTogJ3pBeGlzJyxcbiAgICBBeGlzQ29tcDogWkF4aXNcbiAgfV0sXG4gIGZvcm1hdEF4aXNNYXA6IGZvcm1hdEF4aXNNYXBcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9853\n");

/***/ })

}]);